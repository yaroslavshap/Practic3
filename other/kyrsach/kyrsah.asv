clear all
close all
clc
%вычисл€ем градиент в узле. который находитс€ в центре координат, если нам
%будет дана задача, где узел находитс€ не в центре координат
%мы перенесем всю систему координаты узла в котором ищем градиент
Kr = 0.0;                   %¬клад рандома в рассто€ние между €чейками
Kfi = 1;                    %вклад рандома в угловое рассто€ние между €чейками
N=6;                        %число соседних €чеек
M = 200;                    %начальный делитель дл€ сетки 1/M - начальный примерный размер сетки
for i= 1:N
    r(i) = 2*(1+(rand()-0.5)*Kr)/M;              %рандомим заранее, чтобы €чейки 
    fi_rand(i) = Kfi*2*pi/N*(rand()-0.5);        %всех размеров были подобны друг другу
end
NSells = 10;                                    %число размеров €чеек
for j=1:NSells
    clear xu yu;
   
    for i= 1:N
        r(i) = r(i)/2;                          %уменьшаем €чейку в 2 раза
        xu(i)=r(i)*cos(2*pi/N*(i-1)+fi_rand(i));%массивы координат центров соседних €чеек
        yu(i)=r(i)*sin(2*pi/N*(i-1)+fi_rand(i)); 
    end
    
    
    u = exp(xu)+yu.^3;                            %значение функции в соседних €чейках
    u0 = 1;                                       %значение функции в центральной €чейке
    ax_ex = 1;                                    %точное значение x компоненты градиента 
    ay_ex = 0;                                    %точное значение y компоненты градиента
    xu(N+1) = xu(1);                              
    yu(N+1) = yu(1);
    x= xu/2;                                %массивы координат центров отрезков между центрами €чеек - "вершины"
    y= yu/2;
    %ћетод √аусса-√рина
    for i=1:N
        y_g = y(i+1)-y(i);                 
        x_g = x(i+1)-x(i);
        S(i) = abs(x(i)*y(i+1)-y(i)*x(i+1))*0.5;    %площадь треугольника между центром центральной €чейки и "гранью" 
        nx(i) =y_g;                                 %компоненты нормали к "гран€м" 
        ny(i) = -x_g;                               %("грань" - отрезок между соседними "вершинами")
    end
    n0x(1) = (nx(1) + nx(N))/2;                    
    n0y(1) = (ny(1) + ny(N))/2;                                      
    
    for i= 2:N
        n0x(i) = (nx(i) + nx(i-1))/2;                %компоненты средних нормалей дл€ "вершин"
        n0y(i) = (ny(i) + ny(i-1))/2;
    end
    %Ќахождение градиента методом √аусса-√рина
    gradu_x(j) = 0.5*sum((u+u0).*n0x)/sum(S);
    gradu_y(j) = 0.5*sum((u+u0).*n0y)/sum(S);          %компоненты градиента функции, вычисленные методом √аусса-√рина
    
    
    %ћетод наименьших квадратов
    Lx(1:N) = xu(1:N)-0;                        %все переменные названы как в лекци€х
    Ly(1:N) = yu(1:N)-0;
    f=u(1:N)-u0;
    Lxx=sum(Lx.*Lx);
    Lxy=sum(Lx.*Ly);
    Lyy=sum(Ly.*Ly);
    %Ќахождение градиента методом наименьших кватратов
    ax(j)=(Lyy.*sum(Lx.*f)-Lxy.*sum(Ly.*f))/(Lxx.*Lyy-Lxy.*Lxy);  %компоненты градиента функции, вычисленные ћЌ 
    ay(j)=(Lxx.*sum(Ly.*f)-Lxy.*sum(Lx.*f))/(Lxx.*Lyy-Lxy.*Lxy);
    
    normaMNK(j) = sqrt((ax_ex-ax(j))^2+(ay_ex-ay(j))^2);
    normaGG(j) = sqrt((ax_ex-gradu_x(j))^2+(ay_ex-gradu_y(j))^2);
    M=M*2;
end
M = M/2^(NSells-1);
figure();
    plot(x,y);
    hold on
    quiver(x(1:N),y(1:N), n0x, n0y)

for j=1:NSells-1
    SHMNK(j)=log2(normaMNK(j)/normaMNK(j+1));
    SHGG(j)=log2(normaGG(j)/normaGG(j+1));
    SizeSell(j)=1/(M*2^(j-1));
end

figure();
plot(SizeSell,SHMNK);
hold on
plot(SizeSell,SHGG);
legend('ћЌ ','метод √аусса-√рина');
xlabel('примерный размер €чейки')
ylabel('пор€док сходимости')

SizeSell(NSells)=1/(M*2^(NSells-1));

figure();
plot(SizeSell,normaMNK);
hold on
plot(SizeSell,normaGG);
legend('ћЌ ','метод √аусса-√рина');
xlabel('примерный размер €чейки')
ylabel('норма')




